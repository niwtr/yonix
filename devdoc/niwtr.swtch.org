* swtch
#+begin_src c
void swtch(struct context ** old , struct context * new);
#+end_src

swtch负责上下文切换。它要做的事情有：
1. 把上下文信息（ebp、ebx、esi、edi、eip、esp）保存在old指向的上下文结构体里。
2. 从new里面恢复寄存器（上下文）。


#+begin_src asm
  # Save old callee-save registers
  # eip在哪里？——eip在使用call调用swtch的时候就保存在栈中%ebp之上的位置上了
 

  # Switch stacks

  movl %edx, %esp # new->stack重置栈

  # Load new callee-save registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret # pop %eip
rc asm
#+end_src

首先它从栈里面弹出两个参数到eax和edx。

#+begin_src asm
.globl swtch
swtch:
  movl 4(%esp), %eax # old
  movl 8(%esp), %edx # new
#+end_src

把所有的一堆寄存器压栈。这里有ebp、ebx、esi、edi，但是没有eip。实际上eip早在caller
调用swtch的时候就已经把它压栈了，因此它现在刚好处在ebp之下的位置。该过程由
call指令自动完成。

#+begin_src asm
  pushl %ebp
  pushl %ebx
  pushl %esi
  pushl %edi
#+end_src

随后，它把栈指针赋给eax所指向的参数地址。
#+begin_src asm
movl %esp, (%eax) # 把esp保存。
#+end_src

现在格局如下：
#+BEGIN_SRC c
                                                                                       
  +-----------------------+                      +-----------------------+             
  |          eax          |                      |          edx          |             
  +-------+---------------+                      +---+-------------------+             
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          v                                          |                                 
   +------------+                                    |                                 
   |    esp     |                                    |                                 
   +------------+--->+------------------------+      +------->------------------------+
                     |          edi           |              |        edi(new)        |
                     +------------------------+              +------------------------+
                     |          esi           |              |        esi(new)        |
                     +------------------------+              +------------------------+
                     |          ebx           |              |        ebx(new)        |
                     +------------------------+              +------------------------+
                     |          ebp           |              |        ebp(new)        |
                     +------------------------+              +------------------------+
                     |          eip           |              |        eip(new)        |
                     +------------------------+              +------------------------+
                  
#+end_src

在最后，重置栈指针，把所有寄存器的值按序弹出——注意栈的IO次序是反着的，所以这里需要倒过来pop。
在最后，一句 =ret= 就相当于popl %eip， 它可以把程序计数器eip的值从栈里弹出。这就是上下文切换——swtch的全部了。



* 上下文切换
swtch容易给人造成一种假象：会让人认为所谓的上下文切换就是由swtch完成的，即用户进程swtch到scheduler的进程，再由scheduler
进程swtch到另一个用户进程。这实际上是不对的。一定要注意， *swtch* 切换的是内核态的上下文，而不是用户态。从用户态到内核态切换的桥梁
其实是我们在“中断”里讨论过的trapframe——中断帧。因此实际上上下文切换的过程是：

uproc1的用户态上下文->uproc1的内核态上下文->scheduelr的上下文->uproc2的内核态上下文->uproc2的上下文。

我们分步骤来考虑。假设当前系统正在执行一个用户进程proc1。

1. 来了一个时钟中断，于是CPU负责把proc1程序运行的上下文压栈，构成trapframe的前半部分。这时候，CPU已经进入内核态。转入中断处理程序alltraps。
（在此之前，进入中断描述符表的对应位置，把trapno和errno压栈，也构成trapframe的一部分。）alltraps负责填入trapframe的另一些部分，
于是trapframe就做好了。
2. alltraps把trapframe作为参数调用trap。trap按照trapno指派到 =giveup_cpu= 函数。这一步就像是执行一个系统调用一样。
3.  =giveup_cpu= 调用transform函数，进而调用 =swtch= 过程。
4. =swtch= 过程会保存当前所运行程序的上下文。注意！因为早已经进入内核态了，因此这里所说的“当前所运行程序”是指proc1的内核进程。proc1的内核进程刚好
运行在transform函数处。保存proc1内核上下文之后，swtch还负责恢复scheduler的上下文，使得scheduler能够查找下一个READY态的进程。
5. scheduer找到了下一个READY态的进程proc2，它进行了关键的步骤——偷梁换柱。它调用了 =swtchuvm()= ，把当前的虚拟内存页表设置为进程proc2的页表。
proc2的虚拟内存里保存着proc2的内核栈（kstack）和用户数据。正是因为这一步，才让接下来调用swtch时传入的指针 =p->p_ctxt= 变得有效。
于是触发swtch，swtch负责保存scheduler的上下文，同时恢复proc2的 *内核态* 上下文。
6. 回复了 *proc2* 的内核态上下文。注意proc2上次也是因为时钟中断而被迫放弃CPU的，它所经历的事情是和proc1一样的，所以proc2的内核上下文仍然是在transform函数里的
——正在swtch调用的下一行。于是，沿着调用链，proc2的内核进程从transform历经 =transform->giveup_cpu->trap->alltraps= 一路返回到alltraps。（由于 =giveup_cpu= 和 =transform= 
后面并没有什么语句了，所以编译器可能把二者的返回地址优化掉，于是我们可能会看到transform直接返回到了trap。）
7. alltraps执行完毕，由于内核栈的设计，上下文结构体的后面刚好是trapret，因此程序调入trapret继续执行。trapret负责恢复 *proc2的用户态上下文* ，并用iret指令返回proc2的用户态继续执行。

上下文切换的过程如上所述。总的来说，调用链就是：

proc1--中断-->alltraps->trap-> =giveup_cpu= ->transform->swtch->scheduler->swtch->transform-> =giveup_cpu= ->trap->alltraps->trapret->proc2

内核的虚拟内存只有一个；每个用户进程各有一个虚拟内存。
