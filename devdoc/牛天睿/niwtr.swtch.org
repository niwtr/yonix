# -*- mode: org; -*-

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>

* 我们的初期工作
本文是我工作总结的一部分。按照分工结果，在第一阶段我负责的内容应当有：

1. 系统顶层设计。
2. 引导。
3. 进程数据结构设计。
4. 系统调用设计。

其中“系统顶层设计”需要对操作系统的概念有全面的理解，我已经计划把它总结为另一篇文章。“引导”方面由我和 /刘含/ 共同商量完成。
我的前两个任务都是属于概要设计方面，而后两者则是属于详细设计。详细设计要求具体到设计本身，比如需要设计进程，就需要落实到进程究竟需要哪些东西。
这些内容显然需要对进程调度方面有完全的了解。并且最后一项“系统调用设计”还需要对“中断”有完全的了解。关于这点，
我本身和 /李凌璇/ 同学属于一组（按照 *yonix* 小组的规定，组内再分组），因此我决定在初期先和 /李凌璇/ 共同先把CPU调度和中断的内容研究透彻，再来进行自己的那份工作。
因此从初期工作来看，我和 /李凌璇/ 同学做的内容基本一致，但是我们侧重点不同——我需要研究更多的有关中断、进程表示和进程运行模式（内核态、用户态）的内容，而 *她* 则更加侧重于
CPU调度算法。因此在中期验收的时候，我们对自己的工作各有不同的期望，在完成CPU进程方面的编码工作以后， *她* 希望能单独做出一个有关红黑树和静态CPU调度的演示程序，我则更希望
自己的工作能够先 *融合* 进我们的教材—— *xv6* 里，以验证我对操作系统全局的理解。



* swtch
#+begin_src c
void swtch(struct context ** old , struct context * new);
#+end_src

swtch负责上下文切换。它要做的事情有：
1. 把上下文信息（ebp、ebx、esi、edi、eip、esp）保存在old指向的上下文结构体里。
2. 从new里面恢复寄存器（上下文）。


#+begin_src asm
  # Save old callee-save registers
  # eip在哪里？——eip在使用call调用swtch的时候就保存在栈中%ebp之上的位置上了
 

  # Switch stacks

  movl %edx, %esp # new->stack重置栈

  # Load new callee-save registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret # pop %eip
rc asm
#+end_src

首先它从栈里面弹出两个参数到eax和edx。

#+begin_src asm
.globl swtch
swtch:
  movl 4(%esp), %eax # old
  movl 8(%esp), %edx # new
#+end_src

把所有的一堆寄存器压栈。这里有ebp、ebx、esi、edi，但是没有eip。实际上eip早在caller
调用swtch的时候就已经把它压栈了，因此它现在刚好处在ebp之下的位置。该过程由
call指令自动完成。

#+begin_src asm
  pushl %ebp
  pushl %ebx
  pushl %esi
  pushl %edi
#+end_src

随后，它把栈指针赋给eax所指向的参数地址。其实也就相当于把当前的栈指针赋值给old参数。注意old参数是一个指针的指针，这里的第二个“指针”就是指esp。
#+begin_src asm
movl %esp, (%eax) # 把esp保存。
#+end_src

现在格局如下：
#+BEGIN_SRC c
                                                                                       
  +-----------------------+                      +-----------------------+             
  |          eax          |                      |          edx          |             
  +-------+---------------+                      +---+-------------------+             
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          |                                          |                                 
          v                                          |                                 
   +------------+                                    |                                 
   |    esp     |                                    |                                 
   +------------+--->+------------------------+      +------->------------------------+
                     |          edi           |              |        edi(new)        |
                     +------------------------+              +------------------------+
                     |          esi           |              |        esi(new)        |
                     +------------------------+              +------------------------+
                     |          ebx           |              |        ebx(new)        |
                     +------------------------+              +------------------------+
                     |          ebp           |              |        ebp(new)        |
                     +------------------------+              +------------------------+
                     |          eip           |              |        eip(new)        |
                     +------------------------+              +------------------------+
                  
#+end_src


如果把swtch过程看做是“save”和“load”两个过程的结合，那么上面所做的工作就是save的全部了，save把当前寄存器（上下文）的内容压栈，
把栈指针保存下来。接下来还需要load工作，它负责恢复新的上下文。新的上下文也是之前通过相同的save工作保存下来的，因此它一定是指向某个内存区域的“栈指针”。我们把
这个指针取出来作为新的栈指针，然后按序（这里是倒着的哦！）把新的上下文从栈里弹出来保存在寄存器里。这里load的工作就结束了。
——注意栈的IO次序是反着的，因此我们pop的时候要按照push相反的次序。

在最后，一句 =ret= 就相当于popl %eip， 它可以把程序计数器eip的值从栈里弹出。这就是内核上下文切换——swtch的全部了。

*注意： 这里是ret而不是iret。* 这是一个很有趣的现象。它将会向我们揭示一个很容易让人混淆的假象，“上下文切换”的大幕将就此徐徐展开……


* 上下文切换

我不知道有多少人曾被“swtch”这个名字欺骗了，至少我是这样的，我曾经天真地以为上下文切换就是swtch过程自己的功劳。认为这一个过程就完成了我们所需的全部。

可怕的不是我们只看到了冰山一角，可怕的是我们看到了冰山一角，认为这就是冰山的全部。

操作系统的上下文切换容易给人造成一种假象：会让人认为所谓的上下文切换就是由swtch完成的，即用户进程swtch到scheduler的进程，再由scheduler
进程swtch到另一个用户进程。这实际上是不对的。接下来我们要展开来说，上下文切换实际上是由多步过程共同实现的。

而swtch又确实实现了上下文的切换，而且它还是上下文切换工作的核心。这不禁会让人混淆。在类Unix系统中，一定要注意，
 *swtch* 切换的是内核态的上下文，而不是用户态。从用户态到内核态切换的桥梁
其实是我们在“中断”里讨论过的 *trapframe* ——中断帧。中断帧保持的是一个用户级进程的 *用户态上下文* 。

*可以这么理解：*

在类Unix系统中每个进程有两种状态——用户态和核心态。

用户态的程序运行的是其用户级代码，在其用户栈里运行。每个进程都有一份自己的用户栈。

核心态的程序运行是内核级代码，在其核心栈里运行。每个进程也有一份核心栈。进程的栈是在进程创建的时候用 =kalloc()= 来创建的。

中断帧保存的是进程用户态的上下文信息；context（上下文结构体）保存的是 *进程核心态* 的上下文信息。上下文切换实际上是由两种上下文共同作用的结果。

实际上上下文切换的过程是：

proc_1 的用户态上下文->proc_1 的内核态上下文->scheduelr的上下文->proc_2 的内核态上下文->proc_2 的上下文。

我们分步骤来考虑。假设当前系统正在执行一个用户进程proc_1 。

1. 来了一个时钟中断，于是CPU负责把proc1程序运行的上下文压栈，构成trapframe的前半部分。这时候，CPU已经进入内核态。转入中断处理程序alltraps。（在此之前，进入中断描述符表的对应位置，把trapno和errno压栈，也构成trapframe的一部分。）alltraps负责填入trapframe的另一些部分，于是trapframe就做好了。
2. alltraps把trapframe作为参数调用trap。trap按照trapno指派到 =giveup_cpu= 函数。这一步就像是执行一个系统调用一样。
3.  =giveup_cpu= 调用transform函数，进而调用 =swtch= 过程。
4. =swtch= 过程会保存当前所运行程序的上下文。注意！因为早已经进入内核态了，因此这里所说的“当前所运行程序”是指proc1的内核进程。proc_1 的内核进程刚好运行在transform函数处。保存proc_1 内核上下文之后，swtch还负责恢复scheduler的上下文，使得scheduler能够查找下一个READY态的进程。
5. scheduer找到了下一个READY态的进程proc_2 ，它进行了关键的步骤——偷梁换柱。它调用了 =swtchuvm()= ，把当前的虚拟内存页表设置为进程proc_2 的页表。proc_2 的虚拟内存里保存着proc_2 的内核栈（kstack）和用户数据。正是因为这一步，才让接下来调用swtch时传入的指针 =p->p_ctxt= 变得有效。于是触发swtch，swtch负责保存scheduler的上下文，同时恢复proc2的 *内核态* 上下文。
6. 恢复了 *proc_2* 的内核态上下文。注意proc_2 上次也是因为时钟中断而被迫放弃CPU的，它所经历的事情是和proc_1 一样的，所以proc_2 的内核上下文仍然是在transform函数里的——正在swtch调用的下一行。于是，沿着调用链，proc_2 的内核进程从transform历经 =transform->giveup_cpu->trap->alltraps= 一路返回到alltraps。（由于 =giveup_cpu= 和 =transform= 后面并没有什么语句了，所以编译器可能把二者的返回地址优化掉，于是我们可能会看到transform直接返回到了trap。）
7. alltraps执行完毕，由于内核栈的设计，上下文结构体的后面刚好是trapret，因此程序调入trapret继续执行。trapret负责恢复 *proc_2 的用户态上下文* ，并用iret指令返回proc2的用户态继续执行。

上下文切换的过程如上所述。总的来说，调用链就是：

proc_1 --中断-->alltraps->trap-> （进入proc_1 的内核态） =giveup_cpu= ->transform->swtch->scheduler->swtch->transform-> =giveup_cpu= ->trap->alltraps->trapret->proc_2

内核的虚拟内存只有一个，它通过 =switchkvm()= 过程来加载进CPU的cr3寄存器；每个用户进程各有一个虚拟内存，它通过 =switchuvm()= 进行加载。

经过上面这一串简单的平铺直叙，我唯恐不能道出我心中一种强烈的感觉——上下文切换中最重要的过程，既不是swtch，不是transform（或者xv6里面的sched），
而是两个耦合的操作： =switchuvm= 和 =switchkvm= 。

两个过程做的其实是一对耦合的事情——切换到用户进程的虚拟内存页、（以及）切换到内核进程的虚拟内存页。我们来看一下 =swtchkvm= 的源代码：

#+begin_src c
// Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void
switchkvm(void)
{
  lcr3(V2P(kpgdir));   // switch to the kernel page table
}
#+end_src

只有一行一看就是和硬件相关的语句。它的意思是：

#+begin_src c
load_cr3(virtual_to_physical(kernel_page_directory));
#+end_src

意思很明白了，就是把内核进程虚拟内存的页表地址转换成物理地址，然后把这个物理地址load进cr3寄存器。

cr3寄存器实际上就是页表地址寄存器。也就是，虚拟内存地址寄存器。

想我们是如何做才能让每个进程互相隔离地运行，使得彼此不会污染到对方的地址空间？——就是通过虚拟内存。ok，那么对于每个进程来说，
虚拟内存页表的地址应该存到哪里呢？答案就是cr3寄存器。

这是一个很有意思的寄存器。它让我们觉得一切事物都是假的，我们每个进程都自认为占领了整个内存，整个内存都是可用的。其实我们
每个人都是井底之蛙，我们做的一切操作只会影响到那个禁锢我们的一个小小世界里面。这就像是反乌托邦小说《我们》里说的一样，
所有人都在一个“绿墙”所包围起来的城市里面生活，没有人会过问外面的世界，饭票和玫瑰券就能满足我们的一切需求。
我们每个人都是被禁锢的囚徒，
我们接受这个小世界的统治规则，
接受这个小世界的思想观念，直到终老，不曾越界。

一个更有意思的现象是，不仅我们普通人（用户进程）是住在这个闭锁的小世界（虚拟内存）里的，甚至连小世界的统治者（内核进程）本身，也是
被“困在里面”的。内核进程也被划在了一片虚拟内存里面，它就叫做内核虚拟内存（kvm）。我想统治者住的地方并不比平民好多少。

你有没有想过，创世神（操作系统的编写者）其实是个骗子？你有没有想过，你在上一行写下了一个“int a=0”，不错，你还记住了这个整数
a的地址0x000002。你在下一行开心地想读取变量a的值，却发现是某个奇葩的数值244（是什么并不重要了，总之大概率不是0）。你还兴致勃勃地打开
gdb调试器打印出0x000002这个地址的内容，发现也不是自己所认识的那个样子了。自己仿佛是做了一场梦，现在从梦里醒来进入了一个完全不同的世界。
你在无奈之余，值得痛苦地大骂一声

“骗子。”

这个现象就存在于操作系统的代码里面。这不仅让我想到一句话：

“你想要骗过其他人，首先要骗过你自己。”

我们来看一下scheduler的代码：

#+begin_src c
void scheduler(void)
{
	while (true)
	{
		sti(); //允许时间片中断，中断后trap调用yeild()函数返回
		//RR,找到处于READY状态的进程
		search_through_ptablef(p)
		{
			if (p->p_stat == READY)
			{
				//切换其状态为RUNNING
				proc = p;        //设置当前关照的进程（全局变量）。
				switchuvm(p);    //交换用户虚拟内存
				p->p_stat = SRUN;//设置进程状态
        //从这里离开调度器的上下文转入用户进程。
				swtch(&cpu->scheduler, p->p_ctxt);
        //某个时间片中断！pia的一下CPU又回到了这里！！！
				switchkvm();//FIXME
        //设置当前工作进程为调度器。
        //你会发现这个函数的代码最好写在一个柱面上。：）
				proc = 0;//设置当前关照的进程为调度器。
			}
		}

	}
}
#+end_src

在swtch一行的下面，有一个switchkvm，这一行负责把内核进程的页表加载进来。如果把这一行去掉呢，会怎样？

你会发现后面的这句“proc= 0;”好像不起作用了。

因为proc只存在于内核进程的虚拟地址空间里，而执行switchkvm之前，我们当前cr3寄存器存储的是用户进程的地址空间。
（因为上面有个switchuvm）究竟是哪个倒霉的用户进程呢？管它呢，反正不是内核进程。因此我们虽然有proc的地址，但是这个地址
实际上是无效的，它甚至可能会取到用户进程的某个非法区段。

如果你明白了我的思路，你会发现scheduler的代码其实是环状的，夹在switchuvm和switchkvm两行的部分是运行在用户进程的虚拟空间上的，
而其他的部分则是属于内核自己的地址空间。

这意味着，swtch过程实际上也是在用户进程的地址空间内进行的。于是，

地址空间切换的真正意义在于，它 *加载了即将被切换进程（p）的虚拟地址空间，使得我们可以取到它的中断帧，从而可以让它返回自己的用户态上下文* 。

听起来好绕。

我们来做一个设想：假如scheduler函数里没有switchuvm这一步，就是说我们没有切换到新进程的虚拟地址空间，会发生什么？

swtch过程当然会照常进行，因为swtch过程只会进行核心态的上下文切换。然后我们会进入新进程p的内核栈上下文处继续执行，也就是
p进程的transform函数。在那里，我们返回到trap过程，再由trap返回到trapret，由trapret返回到p的用户态。

听起来好像很完美。但是我们漏下了一步，仔细看：

#+begin_src asm
  # Return falls through to trapret...
.globl trapret
trapret:
  popal
  popl %gs
  popl %fs
  popl %es
  popl %ds
  addl $0x8, %esp  # trapno and errcode
  iret
#+end_src

在trapret过程里，我们从栈里pop出一系列寄存器，并由iret返回用户态进而可以以用户进程的用户态继续执行。但问题是，你现在是在弹谁的栈呢？

*你好像是在弹内核的栈。^_^*

如果这些工作顺利进行下去，你会惊喜地发现，经过了上下文切换，你回到的还是刚才的进程，你的一系列工作都白费了。

因此虚拟空间的切换是十分有必要的，经过了虚拟地址空间切换，我们才能顺利地从栈里面还原新进程中断帧，返回到新进程的用户态。
所以我认为上下文切换的最重要步骤，实际上是两个switchvm。


经过这些头脑风暴和思想洗礼，再来反观操作系统的设计哲学。操作系统的设计目的是为进程提供一个互不干扰、协作、可靠、高效的运行平台。
我们如何让各种进程之间和谐共生、安全而互不干扰？

人们最先想到的做法就是隔离。这太符合社会学了。人们总是异化、隔离、限制那些对当前社会或者意识形态有害的人或者群体，从而使得他们自己所处的社会
能够安全地生存下去。无论是对罪犯还是被孤立的异族群体，这种手段总是最简单粗暴，却最高效。

高明的统治者总是能干净利索地处理这些手续，也就是，让人都感觉不到自己是被隔离了。实现这种手段的就是虚拟内存。虚拟内存是一种毒品，
它让人吃了之后感觉打通了任督二脉，惘若身处大草原，觉得“整个世界都是我的”。

但是人没法做到纯粹的隔离，因为纯粹的隔离就意味着没有人权。有时候我们需要这样那样的权利，却因为自己受到隔离而无法行使。操作系统也为此提供便利，
于是有了系统调用。系统调用是一些内核级别的特权指令，显然不能让众生加以乱用，不然政权将会动荡，社会将会变革。怎么办？

我想行使中央集权的暴君都是一些缺乏安全感的人。他们觉得整个世界上只有他们自己是安全的，其他人都是罪犯。当你对一个人做事没有安全感的时候，
最简单的做法就是自己把事情都处理完，让所有人都别插手。但是这有一个问题：你会累死的。古代中央集权最盛行的时候，皇帝恐怕都是最累的。换到操作系统的话题里，
也就是，你需要频繁地开辟新的内核进程去执行用户进程的请求。于是得用点更“绝”的方法：给他们换脑子，让他们当自己的傀儡，
借用他们的肉体（说得是不是有点露骨^_^）来帮助自己完成任务。

操作系统给进程换脑子的方法就叫做中断。在操作系统的世界里，人（进程）生而有二脑，一个叫做“用户栈”，一个叫做“内核栈”。人可以自由使用自己的“用户栈”脑子，但是自其出生之时，
其“内核栈”脑子就被统治者（操作系统内核）管制着。一旦一个进程被中断，它的脑子（用户栈）就被掏出来，换上他的另一个脑子（内核栈）。
换句话说，这叫“模式转换”。意味着这个进程从用户态转向了内核态。一旦一个进程转向内核态，它就已经被操作系统支配，他执行的是操作系统的内核代码，而不是本身自己的代码。
普通人脑子里或许装着一些危险的思想，与之相反，统治者认为自己的脑子总是安全的。帮助内核执行完代码之后，进程就要穿越回内核态，做自己的事情去。于是操作系统在给人换脑子
之前，还要把原来人家的思想（上下文）保存下来。

有人会问，为什么非得换个脑子，而不是简单地转换思想，洗脑（只使用中断帧做上下文切换）呢？因为统治者认为有些人可能会自毁，他们会自己把自己的脑子弄坏，于是即使被洗脑，脑子也可能是不中用
或者是不安全的，而“内核栈”一直被操作系统自己管辖着，它受到了一系列的保护，因此操作系统认为它是安全的——于是，一个进程在使用int指令陷入内核态的时候，CPU会检查权限，如果发生了特权级变换，CPU就要保存esp和ss两个指针，以便换到内核栈上执行代码以后再返回用户栈。

把“换脑子”这个概念领会明白之后，“上下文切换”的概念就自然清楚，它就是：

用内核的脑子去交换进程的脑子->用内核的脑子去想下一个该调度的进程->用新进程的脑子来换内核的脑子。
